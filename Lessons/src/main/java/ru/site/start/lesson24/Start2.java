package ru.site.start.lesson24;

import java.util.ArrayList;
import java.util.List;

public class Start2 {

    /**
     * Тема: интерфейс
     *
     * У интерфейса можно писать, как абстрактный метод, так и метод с телом, так и константу (ее писать с больших букв).
     * interface Swim_able {
     *     void swim();
     *     int CONTANT = 10;
     * }
     *
     * Если будет сделано имплементирование и в интерфейсе абстрактные методы, то нужно переопределять абстрактные методы в саб-классе
     * Если переопределение не нужно делать, при этом сделано имплементирование, тогда нужно еще дописать abstract на уровне класса. И ошибка пропадет.
     *
     * Интерфейсы: животные (общее слово, не понятно, какое именно животное подразумивается). Абстрактный метод - говорить и замолчать. Создать классы кошки, собаки и так далее и имплементирвровать интерфейс и указать в теле метода как каждый тип должен действовать.
     * Также к интерфейсу относяится мебель. по аналогии с примером выше. а классы - диваны, стулья, столы и так далее. аналогия примеру выше.
     *
     * Если создан интерфейс Figure, и если попробовать создать объект (до равно и после равно Figure), то будет ошибка после равно на Figure. Нельзя создать объект, та как это не класс.
     *
     * У интерфейсов нет кэнстрактэ. Интерфейс - это не класс, у него нет кэнстрактэ. Но у класса если дописать abstract, то можно создать кэнстрактэ и потом сделать наследование в саб-классе и этот кэнстрактэ передастся из базового класса.
     *
     * Уровень доступа у всех верхних интерфейсов (первая линия) или паблик или дэфалт.
     *
     * для интерфеса можно писать слово abstract. Но это лишнее. компилятор все равно добавит это слово. abstract interface ttt { ... }
     *
     * Интерфейс не может быт final, так как нужно имплементировать и  переопределять абстрактные методы.
     *
     * Если не указать самостоятельно, то компилятор добавил в определение всех non-default (не access modifier) и non - static методов слова abstract и public. Это относится к абстрактным методам. К ним ко всем допишется паблик и абстракт, поэтому когда будет переопределяться абстрактный метод, там всегда нужно указывать паблик.
     *
     * Из переменных в интерфейсе могут быть только константы, которые должны быть инициализированы.
     *
     * ==
     * Если будет такая запись (оба класса): Employee e = new Doctor();
     * то если в рабочем 5 методов и 5 переменных, а в классе доктор 20 методов и 20 переменных,
     * то если методы переопределены и переменные те же, они захайдятся (переменны только),
     * то будут доступны только 5 переменных и 5 методов из класса рабочий. Остальные 15 методов и 15 переменных доступны не будут
     * так как какие методы и переменные доступны для вызова определяются кэмпаил тайм (по левой части - по типу).
     * Чтобы все 20 методов и 20 переменных были доступны нужно тип указывать не рабочий, а доктор.
     * ==
     *
     * На объект класса может ссылаться переменная такого же типа, что и сам объект. Затем типы его супер-класса. И типы интерфейса, который имплементировал класс, созданного объекта.
     * То, что есть в супер-классе, есть в саб-классе.
     * И всё, что есть в интерфейсе есть в классе, который делает имплементирование.
     *
     * Если будет создан интерфейс q, и 2 класса w и t, если просто так сделать, то связи не будет между классами и интерфейсом.
     * Но если к каждому классу дописать имплементирование, то потом можно создать объект класса типа интерфейса.
     * Тоже самое по идее должно относится если есть саб-классы, которые не имплементируют интерфейс, но родительский класс имплементирует интерфейс и по идее должно
     * получиться создать объект саб-класса и указать тип интерфейс, так как есть связь.
     */


    // Как писать можно. Ниже будет перегрузка абстрактного метода, так как параметры разные.
//    interface I1 { void abc(int a); }
//    interface I2 { void abc(String s); }
//    class M implements I1, I2 {
//        @Override
//        public void abc(int a) { System.out.println(a); }
//
//        @Override
//        public void abc(String s) { System.out.println(s); }
//    }


    // Как писать нельзя, так как указаны ритен тайп разные, при этом метод называется одинаквого и один параметр одинаковый.
// В этом примере отличие только в return type. Если только он отличается, то так нельзя делать перегруженные методы.
// Будет ошибка компиляции. Нужно еще параметры менять. Если второй параметр дописать и оставить инт в retun type, то так можно будет делать.
//    interface I1 { void abc(int a); }
//    interface I2 { int abc(int a); }
//    class M implements I1, I2 {
//        @Override
//        public void abc(int a) { System.out.println(a); }
//
//        @Override
//        public int abc(int a) { return a; }
//    }

    /**
     * Наследование, которое относится к интерфейсу и к классу:
     * 1. Класс может наследовать 0 или 1 класс.
     * 2. Класс может имплементировать 0, 1, 2 и более интерфейсов.
     * 3. Класс не может наследовать интерфейс.
     * 4. Класс может наследовать класс, который помечен как abstract. А там абстрктные методы должны быть.
     * 5. Интерфейс не может наследовать или имплементировать класс.
     * 6. Интерфейс может наследовать и или более интерфейсов через extends. Пример: interface Help_able extends Swim_able {
     * 6.1. Интерфейс может наследовать более 1 интерфейса. extends и далее можно 1, 2, 3 или более интерфейсов указать.
     * 7. Обычный класс может наследовать обычный класс или abstract class.
     * 8. abstract class может наследовать обычный класс или абстрактный класс и имплементировать интерфейс.
     * 9. Если сначала идет 1-2-3 абстрактный класса и они идут сверху вниз через наследование, то потом должен идти обычный класс
     * и в нем нужно переопределить все абстрактные методы.
     */


    List<String> test = new ArrayList<>(); // Класс ArrayList имплементирует интерфейс List, где абстрактные методы. А в классе ArrayList переопределены абстрактные методы

    // Можно создать класс, сделать имплементацию интерфейса и тогда можно будет создать объетк, как в примере выше для коллекций. тоже самое можно сделать для своего интерфейса и для своего класса, который будет имплементировать интерфейс. В этом случае будет отношение is a, поэтому объект создать можно.


    interface Help_able {
        public abstract void pomosh(); // Джава сама подставит abstract. Это слово писать не обязательно. Тоже самое и для public.
        void tushitPojar();
        int CONTANT = 10; // если так написать, то автоматически допишется public final static. если паблик написать, то допишется файнал и стэтик. Если указать другое слово из трех, то оставшиеся два слова допишутся.
    }

    interface Swim_able {
        void swim();
    }

    static class Employee {

        String name;
        int age;

        Employee(String name, int age) {
            this.name = name;
            this.age = age;
        }

        void eat() {
            System.out.println("Работник ест");
        }
        void sleep() { System.out.println("Работник спит"); }

    }

    static class Doctor extends Employee implements Help_able {
    //Если дописать к классу abstract и implements Help_able, то класс не может создать объект, а также
        // не нужно переопределять методы. Если нужно переопределить методы, то не писать abstract у класса
        String post;

        Doctor(String name, int age, String post) {
            super(name, age);
            this.post = post;
        }

        void doHealth() {
            System.out.println("Доктор лечит");
        }

        // При переопределии методов обязательно писать public у методов, иначе будет ошибка.
        // Писать public у методов, так как в интерфейсу у абстрактного метода уровень доступа паблик, просто
        // он сам дописывается, а здесь не дописывается, поэтому самому паблик нужно писать
        public void pomosh() {}
        public void tushitPojar() {}

    }

    // Ниже указано 2 интерфейса в имплементации
    static class Surgeon extends Doctor implements Help_able, Swim_able {

        int salary;

        Surgeon(String name, int age, String post, int salary) {
            super(name, age, post);
            this.salary = salary;
        }

        void doOperation() {
            System.out.println("Хирург проводит операцию");
        }

        public void pomosh() {}
        public void tushitPojar() {}
        public void swim() {}
        
    }

        public static void main(String[] args) { }

}
