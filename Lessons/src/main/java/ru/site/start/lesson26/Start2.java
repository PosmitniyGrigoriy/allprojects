package ru.site.start.lesson26;

public class Start2 {
}

/**
 * Non-static and static initializers
 *
 * Блоки кода могут быть вне методов. Это статические и не статические инициализаторы.
 * Примеры:
 *
 * static {
 *     саут("111");
 * }
 *
 *
 * {
 *     саут("222);
 * }
 *
 * Инициализаторы могут быть внутри класса, но не внутри метода.
 *
 * Static инициализатор срабатывает один раз, когда класс загружается в память.
 * Non-static инициализатор срабатывает каждый раз, когда создается новый объект этого класса.
 *
 * Не статические инициализаторы нужно использовать тогда, когда нужно, чтобы какой-то код 100% сработал
 * вне зависимости какой кэнстрактэ будет использован, при создании объекта.
 *
 * Код можно, где есть тела: в методах, в кэнстрактэ, в инициализаторах.
 *
 * Пример ниже для не статического инициализатора.
 */

class Test5 {

    int a;

    Test5() {
        System.out.println("Кэкстрактэ 1");
    }

    Test5(int a) {
        this(); // Вызывает кэнстрактэ из текущего класса
        this.a = a;
        System.out.println("Кэнстрактэ 2");
    }
    {
        System.out.println("Hello");
        int a = 10; // Можно в блоке инициализатора объявлять переменную. Скорей можно делать всё в этом блоке.
    }

    static {
        System.out.println("111");
    }
    static {
        System.out.println("000");
    }
}

class Run {
    public static void main(String[] args) {
        System.out.println("---------");
        Test5 t1 = new Test5(); // Первый раз выведется Hello
        System.out.println("---------");
        Test5 t2 = new Test5(); // Второй раз выведется Hello
        System.out.println("---------");
        Test5 t3 = new Test5(3); // Третий раз выведется Hello
        System.out.println("---------");

//        Результат вывода:
//        ---------
//        111
//        000
//        Hello
//        Кэкстрактэ 1
//         ---------
//        Hello
//        Кэкстрактэ 1
//        ---------
//        Hello
//        Кэкстрактэ 1
//        Кэнстрактэ 2
//        ---------

        // Важно: хоть и есть стэтик инициализаторы, но, если закомментировать все строки внутри мэин,
        // кроме двух саутов разделительных (первый и последний), тогда даже стэтик не создастся,
        // не выведется. Чтобы стэтик инициализатор вывелся, обязательно создавать объект. Для данного примера.
        // Так как здесь 2 класса используются. В основном классе, где мэин, нет статических инициализаторов,
        // поэтому они не подгружаются. Но если бы они были бы в основном классе, даже, если в мэин было бы пусто,
        // то сработали бы сауты статических инициализаторов.
        // Тогда, если 3 объекта, то 1 раз сработает стэтик инициализатор.

        /**
         * 1. Сначала вызываются статические переменные и статические инициализаторы - вызываются 1 раз.
         * 2. Затем если создается объект, то вызываются не статические инициализаторы для объекта.
         * 3. Затем вызывается кэнстрактэ.
         *
         * Если объектов 10, то будет 10 вызовов одинаковых, если не статический инициализатор
         * для одного класса. 10 объектов типа Car, то для Car 10 раз один и тот же не статический
         * инициализатор вызовится. Но эти 10 вызовов будут последовательны. Сначала для первого объекта сделается
         * шаг 2 и 3, затем для второго объекта шаг 2-3 и так для 10 объектов.
         */
    }
}

class Run2 {
    int a = 3;

    Run2() {
        a = 4;
    }

    {
        a = 5;
    }

    public static void main(String[] args) {
        Run2  r2 = new Run2();
        System.out.println(r2.a);
    }
}

/**
 * Результат вывода: 4.
 *
 * Сначала создается переменная a. И происходит инициализация. а = 3.
 * Затем вызывается нон стэтик инициализатор. 3 заменяется на 5.
 * Затем вызывается кэнстрактэ и 5 заменяется на 4.
 * Выводится 4.
 */

class A {
    static final int a = 10; // стэтик не изменяемые константы нужно сразу инициализировать.

    // также можно не инициализировать, но тогда нужно использовать стэтик инициализатор и там инициализировать. так работать будет, так как стэтик инициализатор загружается при создании объекта.
    static final int b;
    static {
        b = 5;
    }

    // Также в стэтик инициализаторе нельзя вызывать обычные переменные
    int c = 3;
    static {
//        System.out.println(c); // Ошибка компиляции на переменной с. Нельзя вызывать переменную с, так как она не стэтик
    }

}

class B {

    String s = "ok";

    {
        System.out.println(s);
    }

    static int i = 0;

    static {
        System.out.println(i);
    }

    {
        i += 1;
        System.out.println(i);
    }

    B() {
        System.out.println("Это кэнстрактэ");
    }

    public static void main(String[] args) {
        System.out.println("Привет");
        B b = new B();
    }
}

/**
 * Результат вывода:
 * 0
 * Привет
 * ok
 * 1
 * Это кэнстрактэ
 *
 * Объяснение: хоть на первой строке в мэин идет саут, он в начале не выводится. Далее считывается вторая строка,
 * а там класс В. Там есть стэтик инициализатор. Поэтому сначала выводится саут стэтик инициализатора,
 * затем саут с первой строки
 * затем остальное всё с класса В.
 */

class C {
    static {
        abc(2);
    }

    static void abc(int a) {
        System.out.println(a + " ");
    }

    C() {
        abc(5);
    }

    static {
        abc(4);
    }

    {
        abc(6);
    }

    static {
        new C();
    }

    {
        abc(8);
    }

    public static void main(String[] args) {

    }
}

// Результат вывода: 2, 4, 6, 8, 5 - такой вывод, так как создается объект new C(); . Поэтому срабатывают все варианты. Не статические инициализаторы срабатывают, так как создается объект.
// Если закомментировать строку создания объекта new C(); , то вывод будет 2, 4. Потому что статические методы в основном классе, где есть мэин. Поэтому и срабатывают статические методы, статические переменные и статические инициализаторы.
// Если в этом классе, где мэин, не было бы статического метода, то не было бы саута в консоли.

/**
 * Последовательность инициализации инициализаторов и переменных:
 * 1. Сначала сработают статические блоки и переменные родительского класса
 * 2. Затем сработают статические блоки и переменные дочернего класса.
 * 3. Затем сработают не статические блоки и переменные родительского класса.
 * 4. Затем сработает кэнстрактэ родительского класса.
 * 5. Затем сработает не статические блоки и переменные дочернего класса.
 * 6. Затем сработает кэнстрактэ дочернего класса.
 *
 * Инициализация пунктов 3-6 происходит только и при каждом создании объекта.
 *
 * Пример ниже.
 */

class Animal {
    Animal() { System.out.println("Кэнстрактэ энимал"); }
    static { System.out.println("Стэтик энимал"); }
    { System.out.println("Нон стэтик энимал"); }
}

class Wolf extends Animal {
    Wolf() { System.out.println("Кэнстрактэ волф"); }
    static { System.out.println("Стэтик волф"); }
    { System.out.println("Нон стэтик волф"); }
}

class Dog extends Wolf {
    Dog() { System.out.println("Кэнстрактэ дог"); }
    static { System.out.println("Стэтик дог"); }
    { System.out.println("Нон стэтик дог"); }
}

class Run3 {
    public static void main(String[] args) {
//        Animal animal = new Animal();
        /**
         * Результат вывода, если будет одна строка в мэин Animal animal = new Animal(); :
         * Стэтик энимал
         * Нон стэтик энимал
         * Кэнстрактэ энимал
         */

//        Dog dog = new Dog();
        /**
         * Результат вывода, если будет одна строка в мэин Dog dog = new Dog(); :
         * Стэтик энимал
         * Стэтик волф
         * Стэтик дог
         * Нон стэтик энимал
         * Кэнстрактэ энимал
         * Нон стэтик волф
         * Кэнстрактэ волф
         * Нон стэтик дог
         * Кэнстрактэ дог
         */
    }
}
