package ru.site.start.lesson24;

public class Start3 {
}

/**
 * В интерфейсе в основном пишут абстрактные методы (без тела), но можно писать и с телом
 * Для этого нужно вначало метода дописать default. Это не уровень доступа, а активация стандартной реализации метода
 * (чтобы можно было писать тело метода). Дэфалтный метод в интерфейсе имеет тело и его не нужно переопределять, потому что уже есть тело,
 * но если понадобится, то можно переопределить.
 */

// Пример кода:
interface Za {
    default void say(String message) {
        System.out.println(message);
    }
}

/**
 * Почему был создан дэфалтный метод с телом в интерфейсе:
 * Есть 1 интерфейс, он имплементируется в 100 классов. Нужно добавить 1 новый метод в интерфейс.
 * Но этот метод нужен только в 10 классах из 100. Для этой ситуации нужно создать дэфалтный метод,
 * указать там тело и вызывать этот метод в 10 классах, а в остальных 90 классах этот метод не будет в коде отображен,
 * так как его нужно вызывать вручную. Также метод не нужно добавлять во все классы, который имплементируют этот интерфейс,
 * так как метод дэфалт.
 */

/**
 * В интерфейсе у абстрактного метода уровень доступа паблик. а не дэфалт.
 * А если в интерфейсе создавать метод стандартной реализации (с телом), то у такого метода
 * уровень доступа тоже паблик. а то, что дописывает дэфалт еще - это не уровень доступа, а возможность
 * создать метод с телом. слово паблик не обязательно писать - оно сами допишется при компиляции.
 * А слово дэфалт обязательно писать для методов с телом.
 *
 * Дэфалтные методы (с телом) не должны быть стэтик, файнал или абстракт.
 * Абстракт - не имеет тела, а дэфалт должен иметь тело.
 * Файнал - дэфалтный метод может быть переопределен, а файнал запрещает этол делать.
 * Стэтик методы у интерфеса - не наследуются классом, при имплементировании интерфейса.
 */

// Ниже код. Сначала создается интерфейс и там стандартая реализация метода. Затем создается второй интерфейс.
// Там можно как наследовать стандартный метод, так и сделать его же абстрактным. но тогда нужно убрать дэфалт.
// Пример ниже.
interface W1 { default void abb() { System.out.println("111"); } }
interface W2 extends W1 { void abb(); }

// Слово default можно написать только в интерфейсе. В абстрактном классе или классе нельзя написать.
//default class aaa {} - так нельзя писать. будет ошибка.


// Код ниже можно писать:
// interface P1 { default void abc() { System.out.println("P1"); } }
// interface P2 { default void abc() { System.out.println("P2"); } }
// interface P3 { void abc(); }

// Далее к трем интерфейсам выше пишется код:
//class Test10 implements P1, P2 {}
// abstract class Test11 implements P1, P3 {}
// Будет ошибка на строке название класса, что в первом, что во втором случае.
// Так как не понятно какой метод вызывать первый или второй abc.

// А так писать можно (как ниже). Так как хоть метод abc в интерфейсах одинаковый в плане названия,
// но он переопределяется внутри класса Test12 и Test13, поэтому ошибки нет. Ясно какой метод должен работать.
//class Test12 implements P1, P2 { public void abc() { System.out.println("333"); } }
//class Test13 implements P1, P3 { public void abc() { System.out.println("555"); } }

/**
 * Далее новая тема - статические методы в интерфейсе.
 *
 * Статические методы в интерфейсе похожи на статические методы в классе.
 *
 * можно создавать абстрактные методы или методы стандартной реализации статические.
 * Пример ниже.
 */
interface P10 {
    static void say2() { System.out.println("000"); }; // Так писать можно. Если в интерфейсе делать статический метод, то у него должно быть тело.
//    default static void say3() {}; // Будет ошибка, так как написано лишнее слово - default
}
// Чтобы вызвать статический метод нужно обращаться к названию интерфейса и вызывать статический метод. Пример ниже:
// P10.say2(); - это писать в мэин. Чтобы вызывать статиический метод таким образом не нужно имплементировать данный интерфейс.
// Статический метод нельзя вызывать в мэин таким образом: say2() или Название класса.say2();
// Но в этот класс нужно дописать еще имплементацию интерфейса, но не получится вызывать так статический метод.

// Статический метод интерфейса не наследуется в классе, поэтому в мэин не будет виден.

class ppp {
    public static void main(String[] args) {
        P10.say2(); // Так можно вызывать статический метод.
//        ppp.say2(); // Так нельзя вызывать статический метод. Будет ошибка.
//        say2(); // Так нельзя вызывать статический метод. Будет ошибка.
    }
}

/**
 * Важный момент для вызова статического метода:
 * Если интерфейс в одном пэкэджэ, а вызывать статический метод нужно в другой пэкэджэ,
 * то у интерфейса должен быть уровень доступа public. public interface yyy {}
 * Если будет уровень доступа дэфалт, то интерфейс будет не виден и не получится вызывать статический метод.
 */

/**
 * Если у статическому абстрактному методу не дописать public, то он сам допишется.
 *
 * Статические методы не наследуются ни одном классом, который имплементиует интерфейс.
 * Чтобы вызывать статический метод - нужно использовать имя интерфейса.
 */

/**
 * С 9-ой джавы можно использовать в интерфейсах уровень доступа private на методах: обычного и статического.
 * Обычный метод - это стандартная реализация. Но в данном случае default уже не нужно писать. Достаточно написать private.
 * И статический метод. Там также. Без дэфалт, но с прайвэт. Оба варианта должны быть с телами.
 * А к абстрактному методу нельзя дописать private.
 *
 */
interface P22 {
    private static void say2() { System.out.println("000"); };// Так можно писать. Без default.
    private void say22() { System.out.println("000"); }; // Так можно писать. Без default.
//    private void say222(); // Так нельзя писать. Будет ошибка.
//    private abstract void say2222(); // Так нельзя писать. Будет ошибка. Нельзя вместе писать прайвэт и абстракт.
}

    /**
     * Пока не было уровнея доступа private, был public.
     * protected в интерфейсах писать нельзя.
     *
     * Если пишется private, значит этот метод не может быть абстрактным, так как абстрактный метод нужно переопределить,
     * а для этого уровень доступа должен позволять увидеть метод, а private скрывает метод, поэтому тело метода нужно
     * указывать сразу.
     *
     * private static метод может быть использован внутри static или non-static методов внутри того же интерфейса.
     * Пример ниже, как можно вызывать статический прайвэт метод интерсейса в теле другого метода интерфейса, который
     * стэтик или дэфалт. Оба варианта с телоп пишутся. Пример ниже.
     * interface P22 {
     *     private static void say2() { System.out.println("000"); };// Так можно писать. Без default.
     *     private void say22() { System.out.println("000"); }; // Так можно писать. Без default.
     *
     * default void method3() { say2();}
     * static void method4() { say2();}
     * }
     *
     *
     * private non-static метод НЕ может быть использовать внутри private static методов.
     * В приватном статическом методе нельзя вызывать обычный приватный метод. Можно вызывать
     * только статический метод.
     *
     */

