package ru.site.start.lesson26;

public class Start3 {
}

/**
 * Non-access modifiers
 *
 * 1. transient. Переменные класса с ключевым словом transient не сериализуются. Если указано
 * transient у поля, то поле не будет записываться в файл или в базу данных и при десериализации
 * оно не будет восстанавливаться из потока байтов. Обычно в таких полях хранится промежуточное
 * состояние объекта, которое проще вычислить, чем сериализовать.
 *
 * Сериализация - это преобразования класса в форму пригодную для его сохранения.
 * Например, когда нужно сохранить какой-то класс в файле, в запись в базу данных или передавать через сеть,
 * сначала нужно сериализировать класс, а потом уже хранить.
 *
 * Сериализованные объекты можно восстановить. Этот процесс называется де-сериализация.
 *
 *
 *
 * 2. native. Методы с ключевым словом native реализованы не на Джаве (например, на с).
 * В своем описании они не имеют тела и заканчиваются как абстрактные методы символом ; .
 *
 *
 *
 * 3. synchronized. Методы с ключевым словом synchronized могут быть использованы в одно и то же время
 * только одним потоком.
 *
 * Чтобы понять слово synchronized нужны знания по многопоточности. Также тема сериализации и
 * де-сериализации есть во втором курсе средний уровень. Там это изучить.
 *
 * Пример по synchronized. Есть 1 счет в банке. И 2 человека, которые имеют доступ к этому счету.
 * 2 карты, но у этих карт общий баланс. Если 2 человека пойдут одновременно снимать деньги с карты,
 * а там баланс 100, то каждый если укажет 100, то выведут 200 всего. А если была бы синхронизация,
 * то если одновременно 2 человека вставят карту, и захотят снять деньги, то второй пользователь
 * заблокируется временно, пока первый снимает деньги. Первый снимает, и потом второй сможет снять
 * деньги, если будет что снимать.
 *
 *
 *
 * 4. volatile. Переменные с ключевым словом volatile могут быть изменены разными потоками и данные
 * изменения будут видны во всех потоках.
 *
 * volatile тоже связано с потоками.
 *
 * если переменная указана как volatile, то если будет 3 потока, все 3 потока возьмут копию значения
 * переменной. Например, переменная была равна 5. И все 3 потока будут работать с начальным значением
 * 5. Если первый поток изменит 5 на 3, то об этом не будет знать второй и третий потоки. Там может быть
 * другие значения будут.
 *
 * Если нужно будет изменить значение переменной volatile, то будет работать с оригиналом, и значение
 * изменится.
 *
 *
 *
 * 5. strictfp. Ключевое слово sctictfp в методах и классах ограничивает точность вычислений с
 * float и double по стандарту IEEE.
 *
 * Программы, где используются материматические формулы, астрономия и так далее - там нужна точность.
 * Поэтому нужно использовать на классах и методах sctictfp.
 */


// Каков будет результат компиляции и запуска данного кода?
class Test {
    void abc(short s) { System.out.println("byte"); }
    void abc(int i) { System.out.println("int"); }
    void abc(float f) { System.out.println("float"); }
    void abc(Object o) { System.out.println("Object");}
    public static void main(String[] args) {
        Test t = new Test();
        char c = 55;
        t.abc(c);
        t.abc(false);
        t.abc(3.14);
    }
}
// Вывод: int, Object, Object.


// Каков будет результат компиляции и запуска данного кода?
class X {
    static String s = "";
    { s += "A"; }
    static { s += "B"; }
    { s += "C"; }
}
class Z {
    public static void main(String[] args) {
        System.out.println(X.s);
        System.out.println(X.s);
        new X();
        new X();
        System.out.println(X.s);
    }
}
// Вывод: B, B, BACAC
