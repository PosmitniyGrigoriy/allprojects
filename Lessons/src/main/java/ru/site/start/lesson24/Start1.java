package ru.site.start.lesson24;

public class Start1 {

    // Стандартная реализация метода мэин
//    public static void main(String[] args) {
//    }

    // Добавлен non-access modifier final. Метод мэин также работать будет, как и без final. Если будет указано final,
    // то в саб-классе Start1 нельзя будет передпределять метод мэин или хайдить
//    public final static void main(String[] args) {
//    }

}

/**
 * Тема: абстрактные методы и абстрактные классы
 *
 * Есть класс фигура. Также есть классы квадрат, окружность, прямоугольник. Эти 3 класса наследуются от класса фигура.
 * Фигурка - это абстрактное (широкое название). Не понятно какая именно фигура здесь подразумивается, поэтому
 * нужно дописать к классу abstract. abstract class Figura {} и в тело написать абстрактные методы, а в саб-классах
 * переопределить эти абстрактные методы. В классе abstract class Figura {} можно создавать как абстрактные методы,
 * так и обычные (с телами). Если нужно сделать метод абстрактным (без тела), то дописывать слово abstract.
 * Если тело абстрактного метода не известно как писать, то делать так метод: abstract void ploshadFiguri();
 * Тело будет разное для разных классов. Для класса квадрат одно тело. Для класса окружность другое тело.
 * По разному будет расчитываться площадь конкретной фигуры, поэтому это нужно в саб-классе прописывать тело
 * (переопределять метод).
 * Если у метода есть abstract, то тело не получится указать. Удалять фигурные скобки {...}.
 * //
 * У абстрактных методов не может быть тела.
 * Если класс указан как abstract, то не получится создать объект этого класса.
 *
 * Абстрактный класс или интерфейс нужны, когда у нас есть абстрактное понятие (широкое слово) и по этому классу или
 * интерфейсы мы не планируем создавать объект. Тогда создавать абстрактный класс или интерфейс.
 *
 * Если в классе есть абстрактный метод, то этот класс должен быть абстрактным. дописывать к классу abstract.
 * abstract class Figura { abstract void ploshadFiguri(); }
 * Не может быть такого, чтобы в классе был абстрактный метод, а сам класс был не абстрактным.
 *
 * Абстрактный класс может содержать, а может не содержать абстрактные методы. Может содержать обычные переменные и
 * обычные методы с телами.
 *
 * Дочерний класс должен перезаписать все абстрактные методы абстрактного класса или дочерний класс
 * должен быть абстрактным, чтобы унаследовать абстрактные методы и не переопределять их
 *
 * У абстрактного класса саб-класс тоже быть абстрактным, тогда абстрактные методы из главного класса
 * перейдут в саб-класс как абстрактные.
 *
 * Можно использовать reference variable типа abstract класса, чтобы ссылаться на объект дочернего класса,
 * который не является abstract. Пример: есть 2 класса. abstract class Figura {} и class Kvadrat {}.
 * Можно создать экземпляр Figura f1 = new Kvadrat(); тогда появятся методы из фигуры
 * и они будут переопределен в классе квадрат. Если написать  Figura f1 = new Figura(); , то будет ошибка
 * где создается объект (в правой части после равно).
 *
 * abstract класс не может быть final. Потому что имеет абстрактные методы и их нужно переопределить, а чтобы
 * переопределить абстрактные методы нужен обычный класс и extends, а final не позволяет создавать наследование.
 *
 * abstract class пишут, чтобы класс имел наследников, чтобы наследники пеоерпделеляли абстрактные методы и использовали
 * их. А final запрещает делать наследование. поэтому abstarct и final - не совместимы. Нельзя вместе писать. Но по отдельности можно.
 *
 * Переменные не могут быть abstract. Всё, что касается abstract, относится или к классу или к методу.
 * Создается абстрактный класс и там создаются абстрактные методы (и к классу, и к методам дописывается abstract).
 *
 * У абстрактных классов есть кэнстрактэ, но он не вызывается, так как нельзя создать экземпляр класса. Но кэнстрактэ
 * можно наследовать классом ниже. и там он уже будет работать. код такой у абстрактного класса:
 * Figura(int ploshad) {
 *     this.ploshad = ploshad;
 * }
 *
 * а в саб-классе, который сделал наследование на класс Figura код такой:
 * * Kvadrat(int ploshad) {
 *        super(ploshad);
 *  *     this.ploshad = ploshad;
 *  * }
 *
 * Любой перезаписанный метод должен быть не abstract, так как у метода будет тело.
 * Если в саб-классе нужно сохранить абстрактность у метода, то метод сделать abstract и класс тоже.
 *
 * Для методов нельзя делать: final abstract, private abstract, static abstract. Метод не получится переопределить.
 *
 * Когда делается переопределение нужно указывать тот же уровень доступа, что и у абстрактного метода. Там public.
 * Поэтому писать нужно public.
 *
 * Обычный класс может наследовать абстрактный класс.
 * Абстрактный класс может наследовать обычный класс.
 *
 * Если созданы абстрактные методы в абстрактном классе и потом создается обычный класс и там идет наследование
 * абстрактного класса, то нужно переопределить все абстрактные методы. Если класс (второй) саб-класс тоже будет
 * абстрактный, то переопределять методы не нужно. Но потом создается тогда третий класс (саб-клас) от второго класса, и
 * это уже обычный класс и там нужно переопределить все абстрактные методы, иначе будет ошибка.
 */
