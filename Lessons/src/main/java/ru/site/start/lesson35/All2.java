package ru.site.start.lesson35;

public class All2 {
}




// Задание 1
// Что будет результатом компиляции и запуска данного кода?

//class B extends A {
//
//    public int a = 20;
//
//    public void abc() {
//        System.out.println("child non-static");
//    }
//
//    public static void abc2() {
//        System.out.println("child static");
//    }
//
//    public static void main(String[] args) {
//        B b = new B();
//        System.out.println(b.a);
//        System.out.println(((A) b).a);
//        b.abc();
//        ((A) b).abc();
//        b.abc2();
//        ((A) b).abc2();
//    }
//
//}
//
//class A {
//
//    public int a = 10;
//
//    public void abc() {
//        System.out.println("base non-static");
//    }
//
//    public static void abc2() {
//        System.out.println("base static");
//    }
//
//}

// Результат вывода:

// 20
// 10
// child non-static
// child non-static
// child static
// base static

// Объяснение к коду:
/**
 * Есть класс А. Он имеет переменную, обычный метод и статический метод.
 * Есть класс Б. Он наследует класс А. Хайдит переменную класса А, переопределяет метод abc и
 * хайдит статический метод из класса А.
 * Далее создается объект Б, на которую ссылается переменная Б.
 * Так как при создании объекта указан тип Б (до равно), то вызовится в первом сауте переменная а из класса Б.
 * Затем во втором сауте выводит тоже переменную А от объекта Б (переменная),
 * но указываем тип А (кастим до класса А). Кастить можно. Потому что Б - это всегда А.
 * Так как указан сейчас через кастинг класс А, то переменная А вызовится у класса А (10, а не 20).
 * Выше объяснения - это для вывода первых двух саутов (20 и 10).
 *
 * Дальше идет b.abc(); Ран там происходит проверка. В на что ссылается? На объект класса В.
 * Вызывается метод этого класса, выведется child non-static.
 *
 * Дальше идет ((A) b).abc(); Хоть кастинг нормально проходит, и переменная b стала относится
 * к классу А, но вызов метода abc() происходит ран тайм, и происходит проверка. Переменная b на самом деле
 * ссылается на какой объект? На объект B. Тогда вызовится метод abc() класса В.
 * Поэтому выведется System.out.println("child non-static");
 *
 * Затем идет b.abc2(); Вызов метода abc2() происходит кэмпаил тайм, потому что это стэтик метод.
 * Переменная b относится к классу В, поэтому метод выводит System.out.println("child static");
 *
 * Далее идет ((A) b).abc2(); Здесь тоже самое происходит, только кастим до класса А. Из-за того что
 * кэмпаил тайм определяет какой статический метод будет вызыван из класса А или из класса В,
 * а здесь мы говорим b пускай чувствует себя как А, компилятор воспринимает эту ссылочную переменную
 * b как тип А, поэтому будет вызываться статэк метод abc2() из класса А. Появится на экране
 * System.out.println("base static");
 */








// Задание 2
// Что будет результатом компиляции и запуска данного кода?

//class A {
//
//    public A() {
//        str1 = abc("String1");
//    }
//
//    static String str1 = abc("String2");
//    String str3 = abc("String3");
//
//    {
//        str1 = abc("String4");
//    }
//
//    static {
//        str1 = abc("String5");
//    }
//
//    static String str2 = abc("String6");
//    String str4 = abc("String7");
//
//    public static void main(String args[]) {
//        A a = new A();
//    }
//
//    static String abc(String str) {
//        System.out.println(str);
//        return str;
//    }
//
//}

// Результат вывода:

// String2
// String5
// String6
// String3
// String4
// String7
// String1

// Объяснение к коду:
/**
 * В первую очередь выполняются статические переменные и статические инициализаторы.
 * Они срабатывают по порядку.
 *
 * 1) static String str1 = abc("String2");
 *
 * 2) static {
 *         str1 = abc("String5");
 *    }
 *
 * 3) static String str2 = abc("String6");
 *
 * Дальше в методе мэин мы создаем объект класса А: A a = new A();
 * Перед тем, как сработает кэнстрактэ, срабатывают нон стэтик инициализаторы по порядку.
 *
 * 4) String str3 = abc("String3");
 *
 * 5) {
 *         str1 = abc("String4");
 *    }
 *
 * 6) String str4 = abc("String7");
 *
 * Затем сработает кэнстрактэ.
 *
 * 7) public A() {
 *         str1 = abc("String1");
 *    }
 *
 */








// Задание 9
// Что будет результатом компиляции и запуска данного кода?

//class Test {
//
//    public static void main(String args[]) {
//        int a = abc();
//        System.out.println(a);
//    }
//
//    static int abc() {
//        try {
//            FileInputStream fis = new FileInputStream("file_kotorogo_net.txt");
//        } catch (FileNotFoundException e) {
//            System.out.println("file ne nayden");
//            return 17;
//        } finally {
//            System.out.println("eto finally block");
//        }
//        System.out.println("Programma prodoljaetsya");
//        return 18;
//    }
//
//}

// Результат вывода:

// file ne nayden
// eto finally block
// 17

// Объяснение к коду:
/**
 * Так как не правильно указан файл, выбрасывается иксепшин.
 * Выводится первый саут. Затем метод возвращает 17.
 * Копия этого значения (17) готова возвращена методом.
 * Перед этим выполняется файнали блок. Выводится второй саут.
 * Затем выводится на экране 17.
 * На третий саут программа не заходит и тем более на return 18.
 */










// Задание 10
// Что будет результатом компиляции и запуска данного кода?

//class Test {
//
//    public static void main(String args[]) {
//        int a = abc();
//        System.out.println(a);
//    }
//
//    static int abc() {
//        try {
//            FileInputStream fis = new FileInputStream("file_kotorogo_net.txt");
//        } catch (FileNotFoundException e) {
//            System.out.println("file ne nayden");
//            return 17;
//        } finally {
//            System.out.println("eto finally block");
//            return 16;
//        }
//        System.out.println("Programma prodoljaetsya");
//        return 18;
//    }
//
//}

// Результат вывода:

// Compile time error

// Объяснение к коду:
/**
 * Так как не правильно указан файл, выбрасывается иксепшин.
 * Выводится первый саут. Затем метод возвращает 17.
 * Копия этого значения (17) готова возвращена методом.
 * Перед этим выполняется файнали блок. Выводится второй саут.
 * Значение 17 из первого return заменяется на значение второго return. 16.
 * Теперь на вывод уже будет не 17, а 16.
 * Если есть 1 return в catch блоке, и еще 1 return в finally блоке,
 * то всегда выводиться будет значение return, который в finally блоке.
 * Затем блок finally заканчивается и ниже идет еще третий саут и return 18.
 * Эти 2 строки - анричибл стэйтмэн. Программа никогда не дойдет до этих строк,
 * поэтому будет компиляционная ошибка. Если последние 2 строки закомментировать
 * (саут и return 18), то программа запустится и выведет 3 строки: первый саут,
 * второй саут и 16.
 */







// Задание 11
// Что будет результатом компиляции и запуска данного кода?

//class Book {
//
//    String bookName;
//
//    Book() {
//        Book b1 = new Book();
//        b1.bookName = "Java OCA";
//    }
//
//}
//
//class TestBook {
//
//    public static void main(String args[]) {
//        Book b2 = new Book();
//        b2.bookName = "Java OCP";
//        System.out.println(b2.bookName);
//    }
//
//}

// Результат вывода:

// StackOverflowError

// Объяснение к коду:
/**
 * В мэин есть строка Book b2 = new Book();
 * Джава заходит на new Book(), чтобы создать новый объект, затем видит, что есть кэнстрактэ.
 * Заходит туда. Там на первой строке опять строка создания объекта: Book b1 = new Book();
 * Джава создает снова новый объект, так как там тоже написано new Book(). Для этого нужно снова зайти в кэнстрактэ.
 * Заходит туда на new Book() и опять создает новый объект на этой же строке Book b1 = new Book();
 * и так много раз, пока не появится ошибка StackOverflowError - стэк переполнен (заполняется вся память и выбрасывается ошибка).
 */







// Задание 13
// Что будет результатом компиляции и запуска данного кода?

//class Book {
//}
//
//interface Readable {
//}
//
//class PaperBook extends Book implements Readable {
//}
//
//class ElectronicBook extends Book {
//}
//
//class TestBook {
//
//    public static void main(String args[]) {
//        Readable r = null;
//        ElectronicBook eBook = new ElectronicBook();
//        r = (Readable) eBook;
//    }
//
//}

// Результат вывода:

// ClassCastException

// Объяснение к коду:
/**
 * Переменной r типа Readable ссылаемся на переменную eBook перед этим проделав кастинг до Readable: r = (Readable) eBook;
 * Между Readable и ElectronicBook на первый взгляд нет отношения is a. Но переменная eBook типа ElectronicBook
 * может ссылаться не только на объект new ElectronicBook(), но и на его какой-то саб-класс. Допустим, у него есть саб-класс
 * А, и переменная eBook типа ElectronicBook может ссылаться на объект класса А. Саб-класс ElectronicBook А может
 * имплементировать интерфейс Readable, тогда между Readable и А будет отношение is a.
 * Но джава не знает eBook ссылается на саб-класс ElectronicBook или нет. Поэтому кэмпаил тайм джава пропускает такой код,
 * но рантайм определяется, что eBook ссылается на объект new ElectronicBook(), а не на какой-то его саб-класс.
 * А между ElectronicBook и Readable нет is a, поэтому на строке r = (Readable) eBook; будет ошибка ClassCastException.
 */







// Задание 22
// Что будет результатом компиляции и запуска данного кода?

//class Test {
//
//    public static void main(String args[]) {
//
//        String s = "";
//        while (false) {
//            s += "hello";
//        }
//        System.out.println(s);
//
//    }
//
//}

// Результат вывода:

// Compile time error

// Объяснение к коду:
/**
 * Если в параметрах while false, то тело никогда не выполнится, поэтому на строке s += "hello"; будет ошибка компиляции.
 * Если в параметрах while будет переменная b: while (b) { System.out.println("poka1"); },
 * и если эта переменная b = false, то ошибки компиляции не будет, как в примере выше. И если запустить приложение,
 * то оно запустится, в консоли будет пусто.
 * Но если у while будет условие такое или аналогичное что-то, то будет ошибка компиляции.
 * while (1 != 1) { System.out.println("poka2"); }.
 * Такой цикл нельзя выполнить, так как он никога не выполнится из-за условия и будет ошибка на строке саута - нельзя выполнить.
 */







// Задание 27
// Что будет результатом компиляции и запуска данного кода?

//class A {
//
//    int a = 3;
//
//    int returnA() {
//        System.out.println("Klass A " + a);
//        return a;
//    }
//
//}
//
//class B extends A {
//
//    int a = 5;
//
//    public int returnA() {
//        System.out.println("Klass B " + a);
//        return a;
//    }
//
//    public static void main(String[] args) {
//        A test1 = new B();
//        System.out.println(test1.a + " " + test1.returnA());
//        B test2 = (B) test1;
//        System.out.println(test2.a + " " + test2.returnA());
//    }
//
//}

// Результат вывода:

// Klass B 5
// 3 5
// Klass B 5
// 5 5

// Объяснение к коду:
/**
 * Класс В хайдит переменную а и переопределяет метод returnA.
 * Test1 ссылается на new B().
 * В первом сауте: System.out.println(test1.a + " " + test1.returnA());
 * Переменная а test1.a кэмпаил тайм определяется по типу класса А. Готовится на вывод 3,
 * но пока не выводится, так как еще не весь известен первый саут (там еще метод есть в сауте).
 * test1.returnA() ссылается на объект класса B (... = new B();), поэтому метод будет переопределен
 * и выведется "Klass B " + 5. Также метод, кроме сауте имеет еще return int. Вернет еще 5.
 * И к первой 3 нужно дописать еще 5. Получается вывод в две строки:
 * // Klass B 5
 * // 3 5
 *
 * Затем переменная test2 ссылается на тот же объект, что и test1, но test1 кастится до B.
 * Далее идет второй саут: System.out.println(test2.a + " " + test2.returnA());
 * Переменная а определяется кэпмаил тайм: test2.a. Выводится из класса В, потому что тип В. Выведется 5.
 * Затем идет test2.returnA() - метод вызывается из класса В. Это ран тайм определяется.
 * Метод returnA() в классе В выводит на экран "Klass B " + 5. И возвращает 5. Было 5 и дописалось еще 5.
 * // Klass B 5
 * // 5 5
 */








// Задание 31
// Что будет результатом компиляции и запуска данного кода?

//interface Jumpable{ }
//
//class Cats implements Jumpable { }
//
//class Tiger extends Cats { }
//
//class House { }
//
//class Test {
//
//    public static void main(String[] args) {
//
//        Jumpable j = new Tiger();
//        Tiger t = new Tiger();
//        House h = new House();
//        if(j instanceof Cats) {System.out.println("j is Cat");}
//        if(t instanceof Jumpable) {System.out.println("t is Jumpable");}
//        if(h instanceof Jumpable) {System.out.println("h is Jumpable");}
//
//    }
//
//}

// Результат вывода:

// j is Cat
// t is Jumpable

// Объяснение к коду:
/**
 * j может ссылаться на Tiger? Да.
 * Тип Tiger t может ссылаться на объект new Tiger? Да.
 * Переменная h типа House может ссылаться на объект new House.
 * Это объяснения для первых трех строк внутри метода мэин.
 * На следующих трех строк, где if, объяснения ниже:
 * j может быть instanceof Cats? j какого типа? j типа Jumpable. Jumpable может быть Cats? Да.
 * t какого типа? Tiger. Tiger может быть jumpable? Да.
 * h может быть instanceof Jumpable? h типа House может ссылаться на объект House. И h может также ссылаться
 * на объект класса A. Не понятно откуда взялся этот класс A. А A это саб-класс h. В первом случае,
 * если бы h мог ссылаться на объект типа house, тогда компилятор знал бы что,
 * между houser и jumpable нет связи, но саб-класс А может имплементировать jumpable.
 * И тогда между h, который ссылается на саб-класса А и jumpable, возможна связь is a.
 * Компилятор, зная возможность этой связи is a, не может выдать ошибку на строке
 * if(h instanceof Jumpable) {System.out.println("h is Jumpable");}.
 * На этой строке нет ошибки компиляции. Тогда runtime происходит проверка:
 * j ссылается на объект Tiger. Tiger типа Cats? Да. Поэтому выводится первый саут.
 * t ссылается на объект Tiger. Tiger это Jumpable? Да. Поэтому выводится второй саут.
 * runtime определяет что h ссылается на объект House (после равно). House h = new House(); но строка ниже, где иф
 * if(h instanceof Jumpable) {System.out.println("h is Jumpable");}
 * здесь между j и Jumpable нет связи is a. House - это не Jumpable. Поэтому третий саут не выведется.
 */










// Задание 33
// Что будет результатом компиляции и запуска данного кода?

//class Test{
//
//    public static void main(String[ ] args){
//        int[] array1 = { -3, 2, 0, 8, 1};
//        int[] array2 = { 9, 0, 4, -10 };
//        System.out.println( array1 [ (array1 = array2)[1] ] );
//    }
//
//}

// Результат вывода:

// -3

// Объяснение к коду:
/**
 * array1 ссылается массив со значениям { -3, 2, 0, 8, 1};
 * array2 ссылается массив со значениям { 9, 0, 4, -10 };
 * В сауте указывается array1, затем в скобках пишется (array1 = array2).
 * Это значит array1 начинает ссылаться на тот же массив, что и array2.
 * Связь array1 теряется с { -3, 2, 0, 8, 1}.
 * Элемент массива array1 с индексом 1 (этот индекс указан в сауте в квадратных скобках [1].
 * Индексация начинается с 0, а здесь 1. У array2 индекс 1 - эт значение 0 (после 9).
 * Получается так: array1[0]. Нужно вывести элемент 0 индекса array1.
 * Перед тем, как сработает выражение в квадратных скобках [ (array1 = array2)[1] ]
 * у array1 уже запомнились значения в памяти. И там { -3, 2, 0, 8, 1}
 * Поэтому когда будет итоговая формула вывода в сауте такая array1[0], то выведется -3.
 */









// Задание 35
// Что будет результатом компиляции и запуска данного кода?

//class Test {
//
//    public static void abc() {
//        System.out.print("method abc");
//    }
//
//    public void def() {
//        System.out.println("method def");
//    }
//
//    public static void hig() {
//        abc();
//        def();
//    }
//
//    public static void main(String[] args) {
//        Test t = null;
//        t.hig();
//    }
//
//}

// Результат вывода:

// Compile time error

// Объяснение к коду:
/**
 * Test t = null; - так можно писать. Дело не в этом.
 * В статическом методе hig() нельзя вызывать не статический метод def().
 */










// Задание 42
// Сколько объектов были созданы и сколько объектов будут пригодными для удаления их GC
// на строке с комментарием данного кода?

//class Test1 {
//
//    int[] array1 = {-3, 0, 3};
//
//}
//
//class Test2 {
//
//    public static void main(String[] args) {
//
//        Test1[] array2 = new Test1[5];
//        array2[0] = new Test1();
//        Test1 t = new Test1();
//        array2[1] = t;
//        t = null;
//        array2[1] = null;
//
//// kommentariy
//
//    }
//
//}

// Результат вывода:

// Созданы: 5
// Пригодны для удаления: 2

// Объяснение к коду:
/**
 * Класс Test1 содержит массив. Это тоже объект. Там есть разные варианты оформления кода после равно. Есть вариант, где = new ... Так что это создается новый объект на этой строке.
 * Эта строка Test1[] array2 = new Test1[5]; значит, что создается массив и он состоит из пяти элементов, все элементы пока null.
 * Далее в массив, который был создан: в нулевой элемент этого массива ложится объект класса Test1. array2[0] = new Test1(); В классе Test1 создается массив array1. Поэтому в первой ячейке из 5 сначала создается объект Test1 и внутри этого объекта Test1 создается еще объект array1 (массив).
 * На этой строке: Test1 t = new Test1(); создается объект и внутри этого объекта создается массив.
 * array2[1] = t; объект t ссылается на array2[1]. Ранее создавался массив из 5 элементов и все были null. Здесь заполняетя элемент под первый индекс. А чуть выше в описании заполнялся элемент под индекса 0.
 * t = null; - пропадает связь с объекту t. но у индекса 1 еще остается связь с объектов этим же.
 * array2[1] = null; - пропадает связь с объектом t у элемента индекс 1.
 *
 * Создано 5 объектов, на удаление 2 объекта.
 */








// Задание 46
// Что будет результатом компиляции и запуска данного кода?

//class Test {
//
//    static String s = "";
//
//    public static void main(String[] args) {
//        int[] array = {1, 2, 5, 8};
//        for (int a : array) {
//            for (int j = 0; j < 4; j++) {
//                if (a > 1.5 && a < 6) {
//                    continue;
//                }
//                System.out.println(a);
//                if (j == 1)
//                    break;
//                continue;
//            }
//            continue;
//        }
//    }
//
//}

// Результат вывода:

// 1
// 1
// 8
// 8

// Объяснение к коду:
/**
 * Вначале s пустая. В одномерном массиве лежит 4 значения: 1, 2, 5, 8. Они по очереди поступают в фор ич.
 * Первое значение: a = 1.
 * j = 0. 0 < 4? Да. 1 > 1,5? Нет. Тогда пропускает тело первого иф. Выводим на экран 1. j(0) = 1? Нет. Тогда пропускает тело второго иф и делаем кэнтинию.
 * j = 1. 1 < 4? Да. 1 > 1,5? Нет. Тогда пропускает тело первого иф. Выводим на экран 1. j(1) = 1? Да. Заходим в тело второго иф, а там брэйк. Выходим из цикла фор (второго) и переходим к следующему числу (2).
 * Второе значение: а = 2.
 * j = 0. 0 < 4? Да. 2 > 1,5? Да. 2 < 6? Да. Кэнтинию.
 * j = 1. 1 < 4? Да. 2 > 1,5? Да. 2 < 6? Да. Кэнтинию.
 * j = 2. 2 < 4? Да. 2 > 1,5? Да. 2 < 6? Да. Кэнтинию.
 * j = 3. 3 < 4? Да. 2 > 1,5? Да. 2 < 6? Да. Кэнтинию. Выход из внутреннего фор. Возвращается на первый фор и берет новое значение.
 * Третье значение: а = 5.
 * j = 0. 0 < 4? Да. 5 > 1,5? Да. 5 < 6? Да. Кэнтинию.
 * j = 1. 1 < 4? Да. 5 > 1,5? Да. 5 < 6? Да. Кэнтинию.
 * j = 2. 2 < 4? Да. 5 > 1,5? Да. 5 < 6? Да. Кэнтинию.
 * j = 3. 3 < 4? Да. 5 > 1,5? Да. 5 < 6? Да. Кэнтинию. Выход из внутреннего фор. Возвращается на первый фор и берет новое значение.
 * Четвертое значение: а = 8.
 * j = 0. 0 < 4? Да. 8 > 1,5? Да. 8 < 6? Нет. Тогда пропускает тело первого иф. Выводим на экран 8. j(0) = 1? Нет. Тогда пропускает тело второго иф и делаем кэнтинию.
 * j = 1. 1 < 4? Да. 8 > 1,5? Да. 8 < 6? Нет. Тогда пропускает тело первого иф. Выводим на экран 8. j(1) = 1? Да. Заходим в тело второго иф, а там брэйк. Выходим из цикла фор (второго) и переходим к первому фор. Так как там значения закончились, то заканчивается работа программы.
 *
 * Итого вывод:
 * 1
 * 1
 * 8
 * 8
 */