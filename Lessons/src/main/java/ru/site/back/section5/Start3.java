package ru.site.back.section5;

class Car2 {
	
	// Ниже будет теория по второму типу - обычный внутренний класс.
	
	String color;
	int doorCount;
	Engine engine;
	
	// Старый вариант кэнстрактэ
//	Car2(String color, int doorCount, Engine engine) {
//		this.color = color;
//		this.doorCount = doorCount;
//		this.engine = engine;
//	}
	
	// Новый вариант кэнстрактэ. На первой строке последний параметр изменен и последняя строка this изменена. Здесь сразу будет создаваться новый мотор с указанием мощности, а не отдельно, как было в примере в старом кэнстрактэ
	Car2(String color, int doorCount, int horsePower) {
		this.color = color;
		this.doorCount = doorCount;
		this.engine = this.new Engine(horsePower); // Так создается объект вложенного класса (не стэтик)
	}
	
	// Второй вариант нового кэнстрактэ. В мэин будет и второй вариант показан как работает
	Car2(String color, int doorCount) {
		this.color = color;
		this.doorCount = doorCount;
	}
	
	// Для второго варианта кэнстрактэ нужно создать метод добавления мотора
	public void setEngine(Engine engine) {
		this.engine = engine;
	}
	
	@Override
	public String toString() {
		return "My car: [color=" + color + ", doorCount=" + doorCount + ", engine=" + engine + "]";
	}
	
	public class Engine {
		private int horsePower;
//		static int test = 5; // Если вложенный класс или основной класс не стэтик, то нельзя указывать у элементов стэтик. Если в класс Engine или класс Car2 дописать static, то можно у элементов писать static. но... если основной класс не стэтик, и вложенный класс не стэтик и к переменной добавлен стэтик, а может и к другому чему-то тоже сработает, то если добавить final еще, то можно будет использовать статический элемент в не статических классах.

		Engine(int horsePower) {
			this.horsePower = horsePower;
		}

		@Override
		public String toString() {
			return "My engine: [horsePower=" + horsePower + "]";
		}
		
	}
	
}

public class Start3 {
	public static void main(String[] args) {
		
//		Car2.Engine engine = new Car2.Engine(250); // если класс Engine стэтик, то так создавать можно. Так было в Start2, а в Start3 без стэтик, так что создавать нужно по-другому. Будет показано ниже.
		Car2 car2 = new Car2("Black", 4, 300);
		System.out.println(car2);
		
		Car2 car3 = new Car2("Black", 4);
		Car2.Engine engine = car3.new Engine(150); // Объяснение после равно: сначала объект внешнего класса, затем точка, потом new и указываем мотор.
		car3.setEngine(engine); // Вставляем в машину потом через созданный сеттер, а вывод происходит через String toString.
		System.out.println(engine);
		System.out.println(car3);
		
//		 Car.Engine engine2 = new car.Engine(150); // Такое написание не верно. Нужно сначала обращаться к объекту, а потом создавать недостающую деталь, как показано на строке 65. А на строке 70 показано, создание объекта (нового) через стэтик. Но так как стэтика нет, поэтому так делать нельзя. Стэтик использовался в Start2 на 66 и 71 строках.
		
		Car2.Engine engine3 = new Car2("Yellow", 2).new Engine(500); // На этой строке создается одновременной и внутренний класс и внешний. Превое new создает внешнюю, а второе new внутреннюю. Но тогда теряется ссылка на Car2, и есть ссылка только на мотор, а какой машине принадлежит этот мотор - это уже не известно. Так можно писать, но не использовать такой вариант. Использовать вариант выше, где сначала создается внешний объект, а потом внутренний и во внешний ложится внутренний через сеттер. и машина получила мотор: строки 64, 65, 66 и вывод далее - такой способ использовать. Сначала создаем объект внешнего класса, затем создаем объект внутреннего класса (логично так делать).
		
	}
}

// Если в основном классе будет еще вложенный класс и в основном классе будет переменная private, то она будет видна во вложенном классе. так как вложенный класс имеет отношение к основному классу (так как находится внутри него). Если нужно обратиться в основном классе к переменной, которая во вложенном классе, то нужно сначала создать экземпляр и потом через переменную экземпляра вызвать ту переменную во вложенном классе. Экземпляр создавать вложенного класса (там где есть переменная, которую нужно вызвать), а не текущего.


//Текст далее относится к вложенным классам как стэтик, так и не стэтик классам: вложенные классы могут без проблем нааследовать другой класс, имплементировать, можно устанавливать final на класс. Всё это можно делать на вложенные классы.

